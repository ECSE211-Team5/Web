.TH "ca.mcgill.ecse211.project.Navigation" 3 "Tue Nov 27 2018" "Version 1.0" "ECSE211 - Fall 2018 - Final Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ca.mcgill.ecse211.project.Navigation
.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBNavigation\fP (EV3LargeRegulatedMotor leftMotor, EV3LargeRegulatedMotor rightMotor)  throws OdometerExceptions "
.br
.ti -1c
.RI "double \fBcalculateAngleTo\fP (double x, double y)"
.br
.ti -1c
.RI "void \fBtravelTo\fP (double x, double y)"
.br
.ti -1c
.RI "void \fBtravelToWithCorrection\fP (int x, int y, boolean avoid)"
.br
.ti -1c
.RI "synchronized void \fBmoveWithCorrection\fP (double distance, double theta)"
.br
.ti -1c
.RI "void \fBmoveOneTileWithCorrection\fP (double theta)"
.br
.ti -1c
.RI "synchronized void \fBturnTo\fP (double angle)"
.br
.ti -1c
.RI "void \fBgoThroughTunnel\fP ()  throws Exception "
.br
.ti -1c
.RI "void \fBsearchRingSet\fP (\fBRingSearcher\fP searcher, boolean correct, boolean reset)"
.br
.ti -1c
.RI "void \fBturn\fP (int angle)"
.br
.ti -1c
.RI "void \fBforward\fP (int speed, double distance)"
.br
.ti -1c
.RI "void \fBstop\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static int \fBconvertDistance\fP (double radius, double distance)"
.br
.in -1c
.SH "Detailed Description"
.PP 
The Navigator class extends the functionality of the \fBNavigation\fP class\&. It offers an alternative \fBtravelTo()\fP method which uses a state machine to implement obstacle avoidance\&.
.PP
The Navigator class does not override any of the methods in \fBNavigation\fP\&. All methods with the same name are overloaded i\&.e\&. the Navigator version takes different parameters than the \fBNavigation\fP version\&.
.PP
This is useful if, for instance, you want to force travel without obstacle detection over small distances\&. One place where you might want to do this is in the ObstacleAvoidance class\&. Another place is methods that implement specific features for future milestones such as retrieving an object\&.
.PP
\fBAuthor:\fP
.RS 4
Caspar Cedro 
.PP
Percy Chen 
.PP
Patrick Erath 
.PP
Anssam Ghezala 
.PP
Susan Matuszewski 
.PP
Kamy Moussavi Kafi 
.RE
.PP

.PP
Definition at line 30 of file Navigation\&.java\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.Navigation (EV3LargeRegulatedMotor leftMotor, EV3LargeRegulatedMotor rightMotor) throws \fBOdometerExceptions\fP"
This navigation class constructor sets up our robot to begin navigating a particular map
.PP
\fBParameters:\fP
.RS 4
\fIleftMotor\fP The EV3LargeRegulatedMotor instance for our left motor 
.br
\fIrightMotor\fP The EV3LargeRegulatedMotor instance for our right motor 
.RE
.PP

.PP
Definition at line 61 of file Navigation\&.java\&.
.PP
.nf
62                                 {
63     this\&.odometer = Odometer\&.getOdometer();
64     this\&.leftMotor = leftMotor;
65     this\&.rightMotor = rightMotor;
66     this\&.data = SensorData\&.getSensorData();
67     for (EV3LargeRegulatedMotor motor : new EV3LargeRegulatedMotor[] {this\&.leftMotor,
68         this\&.rightMotor}) {
69       motor\&.stop();
70       motor\&.setAcceleration(Q_ACCELERATION);
71     }
72   }
.fi
.SH "Member Function Documentation"
.PP 
.SS "double ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.calculateAngleTo (double x, double y)"
This method calculate the angle for the robot to rotate facing certain point
.PP
\fBParameters:\fP
.RS 4
\fIx\fP x coordinate of the point 
.br
\fIy\fP y coordinate of the point 
.RE
.PP
\fBReturns:\fP
.RS 4
: rotation needed in degree 
.RE
.PP

.PP
Definition at line 81 of file Navigation\&.java\&.
.PP
.nf
81                                                      {
82     double dX = x - odometer\&.getXYT()[0];
83     double dY = y - odometer\&.getXYT()[1];
84     double theta = Math\&.atan(dX / dY);
85     if (dY < 0 && theta < Math\&.PI)
86       theta += Math\&.PI;
87     return theta;
88   }
.fi
.SS "static int ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.convertDistance (double radius, double distance)\fC [static]\fP"
This method allows the conversion of a distance to the total rotation of each wheel need to cover that distance\&.
.PP
\fBParameters:\fP
.RS 4
\fIradius\fP The radius of our wheels 
.br
\fIdistance\fP The distance traveled 
.RE
.PP
\fBReturns:\fP
.RS 4
A converted distance 
.RE
.PP

.PP
Definition at line 608 of file Navigation\&.java\&.
.PP
.nf
608                                                                     {
609     return (int) ((180\&.0 * distance) / (Math\&.PI * radius));
610   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.forward (int speed, double distance)"
Move the robot forward
.PP
\fBParameters:\fP
.RS 4
\fIspeed\fP speed to be taken 
.br
\fIdistance\fP distacne to travel 
.RE
.PP

.PP
Definition at line 585 of file Navigation\&.java\&.
.PP
.nf
585                                                   {
586     leftMotor\&.setSpeed(speed);
587     rightMotor\&.setSpeed(speed);
588     leftMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, distance * Game\&.TILE), true);
589     rightMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, distance * Game\&.TILE), false);
590   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.goThroughTunnel () throws Exception"
found the tunnel based on the ll and ur coordinate, after the method, the robot will go the the entrance of the tunnel facing the tunnel it returns the distance it needs to go for [x] and [y] in order to go through the tunnel
.PP
\fBExceptions:\fP
.RS 4
\fIException\fP 
.RE
.PP

.PP
Definition at line 374 of file Navigation\&.java\&.
.PP
.nf
374                                                  {
375     int distance = 0;
376     int[] ll, ur;
377     // first use ll and ur coordinate to calculate lr and ul of the tunnel
378     ll = GameParameters\&.TN_LL;
379     ur = GameParameters\&.TN_UR;
380     int[] lr = {ll[0], ur[1]};
381     int[] ul = {ur[0], ll[1]};
382 
383     // clone the four points (to make sure we are not modifying the original one)
384     int[][] corners = {ll\&.clone(), lr\&.clone(), ul\&.clone(), ur\&.clone()};
385     ArrayList<int[]> notIn = new ArrayList<int[]>();
386     ArrayList<int[]> points = new ArrayList<int[]>();
387     double[] position = odometer\&.getXYT();
388 
389     // search for the points that are the same as the current area of the robot
390     // these are the entrance of the tunnel, also find the other two points, those
391     // are the exit of the tunnel
392     GameParameters\&.AreaType type =
393         GameParameters\&.getType((int) Math\&.round(position[0]), (int) Math\&.round(position[1]));
394     for (int[] point : corners) {
395       if (GameParameters\&.getType(point[0], point[1]) == type) {
396         points\&.add(point);
397       } else {
398         notIn\&.add(point);
399       }
400     }
401 
402     // Sort the two point at exit by the distance to the destination
403     if (type == GameParameters\&.AreaType\&.InStarting) {
404       Collections\&.sort(notIn, new GameUtil\&.RingSetComparator());
405     } else if (type == GameParameters\&.AreaType\&.Searching) {
406       Collections\&.sort(notIn, new GameUtil\&.StartingComparator());
407     }
408 
409     // find the direction and length of the tunnel
410     // we know the entrance two points of the tunnel, so this means
411     // the two points must have either x or y coordinate identical\&.
412     // that's the direction of the tunnel as well
413     // after identify it's direction, we find whether it is positive
414     // or negative directed
415     if (points\&.get(0)[0] == points\&.get(1)[0]) {
416       distance = Math\&.abs(notIn\&.get(0)[0] - points\&.get(0)[0]);
417       int multi = notIn\&.get(0)[0] - points\&.get(0)[0] < 0 ? 1 : -1;
418       travelToTunnelEntrance(points, 0, multi);
419       for (int i = 0; i < notIn\&.size(); i++) {
420         // this step is to find the nearest two points that we can go two
421         // after exit the tunnel
422         notIn\&.get(i)[0] = notIn\&.get(i)[0] - multi * 1;
423       }
424     } else {
425       distance = Math\&.abs(notIn\&.get(0)[1] - points\&.get(0)[1]);
426       int multi = notIn\&.get(0)[1] - points\&.get(0)[1] < 0 ? 1 : -1;
427       travelToTunnelEntrance(points, 1, multi);
428       for (int i = 0; i < notIn\&.size(); i++) {
429         // this step is to find the nearest two points that we can go two
430         // after exit the tunnel
431         notIn\&.get(i)[1] = notIn\&.get(i)[1] - multi * 1;
432       }
433     }
434 
435     double[] tunnelEnd = GameUtil\&.average(notIn\&.get(0), notIn\&.get(1));
436     double angleThoughTunnel = Math\&.toDegrees(calculateAngleTo(tunnelEnd[0], tunnelEnd[1]));
437     turnTo(angleThoughTunnel);
438 
439     // goback To correct
440     if (angleThoughTunnel > 0) {
441       moveBackWithCorrection();
442     }
443 
444     // turn left -5 to correct the effect of the weight
445     turn(TUNNEL_CORRECTION);
446     if (distance == 1) {
447       forward(TUNNEL_SPEED, distance + 1 + 0\&.5);
448     } else {
449 
450       forward(TUNNEL_SPEED, distance + 1 + 0\&.5);
451 
452       // forward(TUNNEL_SPEED, distance/2\&.0+0\&.5);
453     }
454 
455     odometer\&.setTheta(angleThoughTunnel);
456     // leftMotor\&.setAcceleration(N_ACCELERATION);
457     // rightMotor\&.setAcceleration(N_ACCELERATION);
458     // // rotate additional sensor distances to make sure the sensor will not on the balck line
459     // leftMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, 2*Game\&.SEN_DIS), true);
460     // rightMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, 2*Game\&.SEN_DIS), false);
461     this\&.moveOneTileWithCorrection(angleThoughTunnel);
462     double[] after = GameUtil\&.average(notIn\&.get(0), notIn\&.get(1));
463     odometer\&.setX(after[0]);
464     odometer\&.setY(after[1]);
465     // go to the nearest safe point near tunnel
466     for (int[] p : notIn) {
467       if (GameUtil\&.isSafe(p)) {
468         double toPointAngle = Math\&.toDegrees(calculateAngleTo(p[0], p[1]));
469         turnTo(toPointAngle);
470         this\&.moveOneTileWithCorrection(toPointAngle);
471         odometer\&.setX(p[0]);
472         odometer\&.setY(p[1]);
473         break;
474       }
475     }
476   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.moveOneTileWithCorrection (double theta)"
This method move the robot one tile until it detect a blackline (ususally one tile)
.PP
\fBParameters:\fP
.RS 4
\fItheta\fP 
.RE
.PP

.PP
Definition at line 246 of file Navigation\&.java\&.
.PP
.nf
246                                                       {
247     // leftMotor\&.setAcceleration(N_ACCELERATION);
248     // rightMotor\&.setAcceleration(N_ACCELERATION);
249     leftMotor\&.setSpeed(FORWARD_SPEED);
250     rightMotor\&.setSpeed(FORWARD_SPEED);
251     leftMotor\&.forward();
252     rightMotor\&.forward();
253     moveUntilLineDetection(true);
254     odometer\&.setTheta(theta);
255   }
.fi
.SS "synchronized void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.moveWithCorrection (double distance, double theta)"
Move a certain distance with correction along current direction (using coordinate system)
.PP
\fBParameters:\fP
.RS 4
\fIdistance\fP distance to cover 
.br
\fItheta\fP theta to be corrected each time 
.RE
.PP

.PP
Definition at line 217 of file Navigation\&.java\&.
.PP
.nf
217                                                                              {
218     leftMotor\&.setSpeed(FORWARD_SPEED);
219     rightMotor\&.setSpeed(FORWARD_SPEED);
220 
221     // correct error of the distance
222     int tiles = Math\&.abs((int) Math\&.round(distance));
223     for (int i = 0; i < tiles; i++) {
224       moveOneTileWithCorrection(theta);
225     }
226   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.searchRingSet (\fBRingSearcher\fP searcher, boolean correct, boolean reset)"

.IP "\(bu" 2
this method approaches the ring set by paying attention to the reading of us sensor, stops at the place when the robot can reach the ring
.PP
.PP
\fBParameters:\fP
.RS 4
\fIsearcher\fP ring searcher 
.br
\fIcorrect\fP whether correct the position when searching ring (cannot do this when at boundary) 
.br
\fIreset\fP whether reset the rod motor to the original position 
.RE
.PP

.PP
Definition at line 520 of file Navigation\&.java\&.
.PP
.nf
520                                                                                    {
521     // Go backward to detect the line and correct the rotation
522     // leftMotor\&.setAcceleration(N_ACCELERATION);
523     // rightMotor\&.setAcceleration(N_ACCELERATION);
524     leftMotor\&.setSpeed(FORWARD_SPEED);
525     rightMotor\&.setSpeed(FORWARD_SPEED);
526     double theta = odometer\&.getXYT()[2];
527 
528     // if we do correction, we need to forward more (for the sensor distance)
529     if (correct) {
530       leftMotor\&.backward();
531       rightMotor\&.backward();
532       moveUntilLineDetection(true);
533       // Forward for 3 cm (approach the ring set)
534       forward(FORWARD_SPEED, 2\&.5 / Game\&.TILE);
535     } else {
536       forward(FORWARD_SPEED, 2 / Game\&.TILE);
537     }
538     // rotate a little to the left to make sure that the sensor can detect the ring
539     leftMotor\&.rotate(LEFT_MOTOR_RING_COR, false);
540     // detect the ring color and beep based on the color
541     searcher\&.search();
542     // rotate back
543     leftMotor\&.rotate(-LEFT_MOTOR_RING_COR, false);
544     // prepare for retrieving the ring
545     searcher\&.prepareRetrieve();
546 
547     // rotate the right motor to behind a little to make sure we can put the rod behind the ring
548     rightMotor\&.rotate(RIGHT_MOTOR_RING_COR, false);
549 
550     // go to the position where ring can be retrieved
551     forward(FORWARD_SPEED, 4 / Game\&.TILE);
552 
553     // rotate a little to the left to make sure not influence the other ring
554     rightMotor\&.rotate(70, false);
555     searcher\&.retrieveRing();
556     // go back to original position
557     rightMotor\&.rotate(-70, false);
558     if (correct) {
559       forward(FORWARD_SPEED, -6\&.5 / Game\&.TILE);
560     } else {
561       forward(FORWARD_SPEED, -6 / Game\&.TILE);
562     }
563     rightMotor\&.rotate(-RIGHT_MOTOR_RING_COR + 20, false);
564     odometer\&.setTheta(theta);
565     if (reset)
566       searcher\&.resetRodMotor();
567   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.stop ()"
Stop the motor 
.PP
Definition at line 595 of file Navigation\&.java\&.
.PP
.nf
595                      {
596     leftMotor\&.stop(true);
597     rightMotor\&.stop(false);
598   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.travelTo (double x, double y)"
Travel to a point naively: by rotating the robot facing the point first and then go to the point
.PP
\fBParameters:\fP
.RS 4
\fIx\fP x coordinate of the point 
.br
\fIy\fP y coordinate of the points 
.RE
.PP

.PP
Definition at line 97 of file Navigation\&.java\&.
.PP
.nf
97                                            {
98     double dX = x - odometer\&.getXYT()[0];
99     double dY = y - odometer\&.getXYT()[1];
100     double theta = calculateAngleTo(x, y);
101 
102     // Euclidean distance calculation\&.
103     double distance = Math\&.sqrt(Math\&.pow(dX, 2) + Math\&.pow(dY, 2));
104 
105     turnTo(Math\&.toDegrees(theta));
106 
107     leftMotor\&.setSpeed(FORWARD_SPEED);
108     rightMotor\&.setSpeed(FORWARD_SPEED);
109 
110     leftMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, distance * Game\&.TILE), true);
111     rightMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, distance * Game\&.TILE), false);
112   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.travelToWithCorrection (int x, int y, boolean avoid)"
This method travel the robot to desired position by following the line (Always rotate 90 degree), along with a correction
.PP
When avoid=true, the nav thread will handle traveling\&. If you want to travel without avoidance, this is also possible\&. In this case, the method in the \fBNavigation\fP class is used\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP The x coordinate to travel to (in cm) 
.br
\fIy\fP The y coordinate to travel to (in cm) 
.br
\fIavoid\fP the robot will pay attention to the distance from ultrasonic sensor to avoid abstacle when navigating 
.RE
.PP

.PP
Definition at line 126 of file Navigation\&.java\&.
.PP
.nf
126                                                                   {
127     int px = (int) Math\&.round(odometer\&.getXYT()[0]);
128     int py = (int) Math\&.round(odometer\&.getXYT()[1]);
129     int[] cur = {px, py};
130     int[] destination = {x, y};
131     ArrayList<Character> instruction = new ArrayList<Character>();
132 
133     // use path finder to find path based on different area the robot is at
134     // OUT: instruction: contains a list of instruction for the robot to move to the destination
135     if (GameParameters\&.getType(px, py) == GameParameters\&.AreaType\&.InStarting) {
136       GameUtil\&.startingFinder\&.tryFindPath(cur, destination, instruction);
137     } else {
138       GameUtil\&.searchingFinder\&.tryFindPath(cur, destination, instruction);
139     }
140 
141     // use the instruction modified by the pathFind to move to the destination
142     char lastStep = ' ';
143     int theta = 0;
144 
145     while (instruction\&.size() > 0) {
146       char step = instruction\&.remove(instruction\&.size() - 1);
147       // if the step is different from the last one, rotate to corresponding rotation
148       if (step != lastStep) {
149         theta = charToRotation(step);
150         turnTo(theta);
151       }
152 
153       // add a value to the robot traveled distance
154       if (step == GameUtil\&.leftInstruction) {
155         px--;
156       } else if (step == GameUtil\&.rightInstruction) {
157         px++;
158       } else if (step == GameUtil\&.upInstruction) {
159         py++;
160       } else {
161         py--;
162       }
163       lastStep = step;
164 
165       moveWithCorrection(1, theta);
166       // get the position of the robot
167       double[] position = odometer\&.getXYT();
168       if (Math\&.round(position[0]) == px && Math\&.round(position[1]) == py) {
169         // this means that the robot is at the point, so set the position to the point
170         odometer\&.setX(px);
171         odometer\&.setY(py);
172       } else {
173         // otherwise some problem might happened and we are not at the desired point, push the
174         // instruction back
175         instruction\&.add(step);
176         // reset the added value to last point
177         if (step == GameUtil\&.leftInstruction) {
178           px++;
179         } else if (step == GameUtil\&.rightInstruction) {
180           px--;
181         } else if (step == GameUtil\&.upInstruction) {
182           py--;
183         } else {
184           py++;
185         }
186       }
187     }
188   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.turn (int angle)"
Rotate the robot by certain angle
.PP
\fBParameters:\fP
.RS 4
\fIangle\fP The angle to rotate our robot to 
.RE
.PP

.PP
Definition at line 574 of file Navigation\&.java\&.
.PP
.nf
574                               {
575     leftMotor\&.rotate(convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, angle), true);
576     rightMotor\&.rotate(-convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, angle), false);
577   }
.fi
.SS "synchronized void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.turnTo (double angle)"
This method is where the logic for the odometer will run\&. Use the methods provided from the OdometerData class to implement the odometer\&.
.PP
\fBParameters:\fP
.RS 4
\fIangle\fP The angle we want our robot to turn to (in degrees) 
.br
\fIasync\fP whether return instantaneously 
.RE
.PP

.PP
Definition at line 344 of file Navigation\&.java\&.
.PP
.nf
344                                                 {
345     double dTheta;
346 
347     dTheta = angle - odometer\&.getXYT()[2];
348     if (dTheta < 0)
349       dTheta += 360;
350 
351     // TURN RIGHT
352     if (dTheta > 180) {
353       leftMotor\&.setSpeed(ROTATE_SPEED);
354       rightMotor\&.setSpeed(ROTATE_SPEED);
355       leftMotor\&.rotate(-convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, 360 - dTheta), true);
356       rightMotor\&.rotate(convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, 360 - dTheta), false);
357     }
358     // TURN LEFT
359     else {
360       leftMotor\&.setSpeed(ROTATE_SPEED);
361       rightMotor\&.setSpeed(ROTATE_SPEED);
362       leftMotor\&.rotate(convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, dTheta), true);
363       rightMotor\&.rotate(-convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, dTheta), false);
364     }
365   }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for ECSE211 - Fall 2018 - Final Project from the source code\&.
