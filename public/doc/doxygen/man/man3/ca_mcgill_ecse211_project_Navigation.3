.TH "ca.mcgill.ecse211.project.Navigation" 3 "Mon Nov 26 2018" "Version 1.0" "ECSE211 - Fall 2018 - Final Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ca.mcgill.ecse211.project.Navigation
.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBNavigation\fP (EV3LargeRegulatedMotor leftMotor, EV3LargeRegulatedMotor rightMotor)  throws OdometerExceptions "
.br
.ti -1c
.RI "double \fBcalculateAngleTo\fP (double x, double y)"
.br
.ti -1c
.RI "void \fBtravelTo\fP (double x, double y)"
.br
.ti -1c
.RI "void \fBtravelToWithCorrection\fP (int x, int y, boolean avoid)"
.br
.ti -1c
.RI "synchronized void \fBmoveWithCorrection\fP (double distance, double theta)"
.br
.ti -1c
.RI "void \fBmoveOneTileWithCorrection\fP (double theta)"
.br
.ti -1c
.RI "synchronized void \fBturnTo\fP (double angle)"
.br
.ti -1c
.RI "void \fBgoThroughTunnel\fP ()  throws Exception "
.br
.ti -1c
.RI "void \fBsearchRingSet\fP (\fBRingSearcher\fP searcher, boolean correct, boolean reset)"
.br
.ti -1c
.RI "void \fBturn\fP (int angle)"
.br
.ti -1c
.RI "void \fBforward\fP (int speed, double distance)"
.br
.ti -1c
.RI "void \fBstop\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static int \fBconvertDistance\fP (double radius, double distance)"
.br
.in -1c
.SH "Detailed Description"
.PP 
The Navigator class extends the functionality of the \fBNavigation\fP class\&. It offers an alternative \fBtravelTo()\fP method which uses a state machine to implement obstacle avoidance\&.
.PP
The Navigator class does not override any of the methods in \fBNavigation\fP\&. All methods with the same name are overloaded i\&.e\&. the Navigator version takes different parameters than the \fBNavigation\fP version\&.
.PP
This is useful if, for instance, you want to force travel without obstacle detection over small distances\&. One place where you might want to do this is in the ObstacleAvoidance class\&. Another place is methods that implement specific features for future milestones such as retrieving an object\&.
.PP
\fBAuthor:\fP
.RS 4
Caspar Cedro 
.PP
Percy Chen 
.PP
Patrick Erath 
.PP
Anssam Ghezala 
.PP
Susan Matuszewski 
.PP
Kamy Moussavi Kafi 
.RE
.PP

.PP
Definition at line 32 of file Navigation\&.java\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.Navigation (EV3LargeRegulatedMotor leftMotor, EV3LargeRegulatedMotor rightMotor) throws \fBOdometerExceptions\fP"
This navigation class constructor sets up our robot to begin navigating a particular map
.PP
\fBParameters:\fP
.RS 4
\fIleftMotor\fP The EV3LargeRegulatedMotor instance for our left motor 
.br
\fIrightMotor\fP The EV3LargeRegulatedMotor instance for our right motor 
.RE
.PP

.PP
Definition at line 63 of file Navigation\&.java\&.
.PP
.nf
64                                 {
65     this\&.odometer = Odometer\&.getOdometer();
66     this\&.leftMotor = leftMotor;
67     this\&.rightMotor = rightMotor;
68     this\&.data = SensorData\&.getSensorData();
69     for (EV3LargeRegulatedMotor motor : new EV3LargeRegulatedMotor[] {this\&.leftMotor,
70         this\&.rightMotor}) {
71       motor\&.stop();
72       motor\&.setAcceleration(Q_ACCELERATION);
73     }
74   }
.fi
.SH "Member Function Documentation"
.PP 
.SS "double ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.calculateAngleTo (double x, double y)"
This method calculate the angle for the robot to rotate facing certain point 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP x coordinate of the point 
.br
\fIy\fP y coordinate of the point 
.RE
.PP
\fBReturns:\fP
.RS 4
: rotation needed in degree 
.RE
.PP

.PP
Definition at line 82 of file Navigation\&.java\&.
.PP
.nf
82                                                      {
83     double dX = x - odometer\&.getXYT()[0];
84     double dY = y - odometer\&.getXYT()[1];
85     double theta = Math\&.atan(dX / dY);
86     if (dY < 0 && theta < Math\&.PI)
87       theta += Math\&.PI;
88     return theta;
89   }
.fi
.SS "static int ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.convertDistance (double radius, double distance)\fC [static]\fP"
This method allows the conversion of a distance to the total rotation of each wheel need to cover that distance\&.
.PP
\fBParameters:\fP
.RS 4
\fIradius\fP The radius of our wheels 
.br
\fIdistance\fP The distance traveled 
.RE
.PP
\fBReturns:\fP
.RS 4
A converted distance 
.RE
.PP

.PP
Definition at line 591 of file Navigation\&.java\&.
.PP
.nf
591                                                                     {
592     return (int) ((180\&.0 * distance) / (Math\&.PI * radius));
593   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.forward (int speed, double distance)"
Move the robot forward
.PP
\fBParameters:\fP
.RS 4
\fIspeed\fP speed to be taken 
.br
\fIdistance\fP distacne to travel 
.RE
.PP

.PP
Definition at line 568 of file Navigation\&.java\&.
.PP
.nf
568                                                   {
569     leftMotor\&.setSpeed(speed);
570     rightMotor\&.setSpeed(speed);
571     leftMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, distance * Game\&.TILE), true);
572     rightMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, distance * Game\&.TILE), false);
573   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.goThroughTunnel () throws Exception"
found the tunnel based on the ll and ur coordinate, after the method, the robot will go the the entrance of the tunnel facing the tunnel it returns the distance it needs to go for [x] and [y] in order to go through the tunnel
.PP
\fBExceptions:\fP
.RS 4
\fIException\fP 
.RE
.PP

.PP
Definition at line 363 of file Navigation\&.java\&.
.PP
.nf
363                                                  {
364     int distance = 0;
365     int[] ll, ur;
366     //first use ll and ur coordinate to calculate lr and ul of the tunnel
367     ll = GameParameters\&.TN_LL;
368     ur = GameParameters\&.TN_UR;
369     int[] lr = {ll[0], ur[1]};
370     int[] ul = {ur[0], ll[1]};
371     
372     //clone the four points (to make sure we are not modifying the original one)
373     int[][] corners = {ll\&.clone(), lr\&.clone(), ul\&.clone(), ur\&.clone()};
374     ArrayList<int[]> notIn = new ArrayList<int[]>();
375     ArrayList<int[]> points = new ArrayList<int[]>();
376     double[] position = odometer\&.getXYT();
377     
378     //search for the points that are the same as the current area of the robot
379     //these are the entrance of the tunnel, also find the other two points, those
380     //are the exit of the tunnel
381     GameParameters\&.AreaType type = GameParameters\&.getType((int) Math\&.round(position[0]), (int) Math\&.round(position[1]));
382     for (int[] point : corners) {
383       if (GameParameters\&.getType(point[0], point[1]) == type) {
384         points\&.add(point);
385       } else {
386         notIn\&.add(point);
387       }
388     }
389     
390     //Sort the two point at exit by the distance to the destination
391     if(type == GameParameters\&.AreaType\&.InStarting) {
392       Collections\&.sort(notIn, new GameUtil\&.RingSetComparator());
393     }else if(type == GameParameters\&.AreaType\&.Searching) {
394       Collections\&.sort(notIn, new GameUtil\&.StartingComparator());
395     }
396     
397     //find the direction and length of the tunnel
398     //we know the entrance two points of the tunnel, so this means 
399     //the two points must have either x or y coordinate identical\&.
400     //that's the direction of the tunnel as well
401     //after identify it's direction, we find whether it is positive 
402     //or negative directed
403     if (points\&.get(0)[0] == points\&.get(1)[0]) {
404       distance = Math\&.abs(notIn\&.get(0)[0] - points\&.get(0)[0]);
405       int multi = notIn\&.get(0)[0] - points\&.get(0)[0] < 0 ? 1 : -1;
406       travelToTunnelEntrance(points, 0, multi);
407       for (int i = 0; i < notIn\&.size(); i++) {
408         //this step is to find the nearest two points that we can go two
409         //after exit the tunnel
410         notIn\&.get(i)[0] = notIn\&.get(i)[0] - multi * 1;
411       }
412     } else {
413       distance = Math\&.abs(notIn\&.get(0)[1] - points\&.get(0)[1]);
414       int multi = notIn\&.get(0)[1] - points\&.get(0)[1] < 0 ? 1 : -1;
415       travelToTunnelEntrance(points, 1, multi);
416       for (int i = 0; i < notIn\&.size(); i++) {
417       //this step is to find the nearest two points that we can go two
418       //after exit the tunnel
419         notIn\&.get(i)[1] = notIn\&.get(i)[1] - multi * 1;
420       }
421     }
422     
423     double[] tunnelEnd = GameUtil\&.average(notIn\&.get(0), notIn\&.get(1));
424     double angleThoughTunnel = Math\&.toDegrees(calculateAngleTo(tunnelEnd[0], tunnelEnd[1]));
425     turnTo(angleThoughTunnel);
426     
427     // goback To correct
428     moveBackWithCorrection();
429 
430     // turn left -5 to correct the effect of the weight
431     this\&.turn(TUNNEL_CORRECTION);
432       if(distance == 1) {  
433         forward(TUNNEL_SPEED, distance+1+0\&.5);
434       }else {
435         forward(TUNNEL_SPEED, distance/2\&.0+1);
436         turn(TUNNEL_CORRECTION);
437         forward(TUNNEL_SPEED, distance/2\&.0+0\&.5);
438       }
439 
440     odometer\&.setTheta(angleThoughTunnel);
441     leftMotor\&.setAcceleration(N_ACCELERATION);
442     rightMotor\&.setAcceleration(N_ACCELERATION);
443 //    // rotate additional sensor distances to make sure the sensor will not on the balck line
444 //    leftMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, 2*Game\&.SEN_DIS), true);
445 //    rightMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, 2*Game\&.SEN_DIS), false);
446     this\&.moveOneTileWithCorrection(angleThoughTunnel);
447     double[] after = GameUtil\&.average(notIn\&.get(0), notIn\&.get(1));
448     odometer\&.setX(after[0]);
449     odometer\&.setY(after[1]);
450     // go to the nearest safe point near tunnel
451     for (int[] p : notIn) {
452       if (GameUtil\&.isSafe(p)) {
453         double toPointAngle = Math\&.toDegrees(calculateAngleTo(p[0], p[1]));
454         turnTo(toPointAngle);
455         this\&.moveOneTileWithCorrection(toPointAngle);
456         odometer\&.setX(p[0]);
457         odometer\&.setY(p[1]);
458         break;
459       }
460     }
461   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.moveOneTileWithCorrection (double theta)"
This method move the robot one tile until it detect a blackline (ususally one tile) 
.PP
\fBParameters:\fP
.RS 4
\fItheta\fP 
.RE
.PP

.PP
Definition at line 241 of file Navigation\&.java\&.
.PP
.nf
241                                                       {
242     leftMotor\&.setAcceleration(N_ACCELERATION);
243     rightMotor\&.setAcceleration(N_ACCELERATION);
244     leftMotor\&.setSpeed(FORWARD_SPEED);
245     rightMotor\&.setSpeed(FORWARD_SPEED);
246     leftMotor\&.forward();
247     rightMotor\&.forward();
248     moveUntilLineDetection(true);
249     odometer\&.setTheta(theta);
250   }
.fi
.SS "synchronized void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.moveWithCorrection (double distance, double theta)"
Move a certain distance with correction along current direction (using coordinate system)
.PP
\fBParameters:\fP
.RS 4
\fIdistance\fP distance to cover 
.br
\fItheta\fP theta to be corrected each time 
.RE
.PP

.PP
Definition at line 213 of file Navigation\&.java\&.
.PP
.nf
213                                                                              {
214     leftMotor\&.setSpeed(FORWARD_SPEED);
215     rightMotor\&.setSpeed(FORWARD_SPEED);
216 
217     // correct error of the distance
218     int tiles = Math\&.abs((int) Math\&.round(distance));
219     for (int i = 0; i < tiles; i++) {
220       moveOneTileWithCorrection(theta);
221     }
222   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.searchRingSet (\fBRingSearcher\fP searcher, boolean correct, boolean reset)"

.IP "\(bu" 2
this method approaches the ring set by paying attention to the reading of us sensor, stops at the place when the robot can reach the ring 
.PP
\fBParameters:\fP
.RS 4
\fIsearcher\fP ring searcher 
.br
\fIcorrect\fP whether correct the position when searching ring (cannot do this when at boundary) 
.br
\fIreset\fP whether reset the rod motor to the original position 
.RE
.PP

.PP

.PP
Definition at line 503 of file Navigation\&.java\&.
.PP
.nf
503                                                                                    {
504     //Go backward to detect the line and correct the rotation
505     leftMotor\&.setAcceleration(N_ACCELERATION);
506     rightMotor\&.setAcceleration(N_ACCELERATION);
507     leftMotor\&.setSpeed(FORWARD_SPEED);
508     rightMotor\&.setSpeed(FORWARD_SPEED);
509     double theta = odometer\&.getXYT()[2];
510     
511     // if we do correction, we need to forward more (for the sensor distance)
512     if(correct) {
513       leftMotor\&.backward();
514       rightMotor\&.backward();
515       moveUntilLineDetection(true);
516       //Forward for 3 cm (approach the ring set)
517       forward(FORWARD_SPEED, 2\&.5/Game\&.TILE);
518     }else {
519       forward(FORWARD_SPEED, 2/Game\&.TILE);
520     }
521     //rotate a little to the left to make sure that the sensor can detect the ring
522     leftMotor\&.rotate(LEFT_MOTOR_RING_COR, false);
523     //detect the ring color and beep based on the color
524     searcher\&.search();
525     //rotate back
526     leftMotor\&.rotate(-LEFT_MOTOR_RING_COR, false);
527     //prepare for retrieving the ring 
528     searcher\&.prepareRetrieve();
529     
530     //rotate the right motor to behind a little to make sure we can put the rod behind the ring
531     rightMotor\&.rotate(RIGHT_MOTOR_RING_COR, false);
532     
533     //go to the position where ring can be retrieved
534     forward(FORWARD_SPEED, 4/Game\&.TILE);
535     
536     //rotate a little to the left to make sure not influence the other ring
537     rightMotor\&.rotate(70, false);
538     searcher\&.retrieveRing();
539     //go back to original position
540     rightMotor\&.rotate(-70, false);
541     if(correct) {
542       forward(FORWARD_SPEED, -6\&.5/Game\&.TILE);
543     }else {
544       forward(FORWARD_SPEED, -6/Game\&.TILE);
545     }
546     rightMotor\&.rotate(-RIGHT_MOTOR_RING_COR+20, false);
547     odometer\&.setTheta(theta);
548     if(reset)
549       searcher\&.resetRodMotor();
550   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.stop ()"
Stop the motor 
.PP
Definition at line 578 of file Navigation\&.java\&.
.PP
.nf
578                      {
579     leftMotor\&.stop(true);
580     rightMotor\&.stop(false);
581   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.travelTo (double x, double y)"
Travel to a point naively: by rotating the robot facing the point first and then go to the point 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP x coordinate of the point 
.br
\fIy\fP y coordinate of the points 
.RE
.PP

.PP
Definition at line 96 of file Navigation\&.java\&.
.PP
.nf
96                                            {
97     double dX = x - odometer\&.getXYT()[0];
98     double dY = y - odometer\&.getXYT()[1];
99     double theta = calculateAngleTo(x, y);
100 
101     // Euclidean distance calculation\&.
102     double distance = Math\&.sqrt(Math\&.pow(dX, 2) + Math\&.pow(dY, 2));
103 
104     turnTo(Math\&.toDegrees(theta));
105 
106     leftMotor\&.setSpeed(FORWARD_SPEED);
107     rightMotor\&.setSpeed(FORWARD_SPEED);
108 
109     leftMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, distance * Game\&.TILE), true);
110     rightMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, distance * Game\&.TILE), false);
111   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.travelToWithCorrection (int x, int y, boolean avoid)"
This method travel the robot to desired position by following the line (Always rotate 90 degree), along with a correction
.PP
When avoid=true, the nav thread will handle traveling\&. If you want to travel without avoidance, this is also possible\&. In this case, the method in the \fBNavigation\fP class is used\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP The x coordinate to travel to (in cm) 
.br
\fIy\fP The y coordinate to travel to (in cm) 
.br
\fIavoid\fP the robot will pay attention to the distance from ultrasonic sensor to avoid abstacle when navigating 
.RE
.PP

.PP
Definition at line 125 of file Navigation\&.java\&.
.PP
.nf
125                                                                   {
126     int px = (int) Math\&.round(odometer\&.getXYT()[0]);
127     int py = (int) Math\&.round(odometer\&.getXYT()[1]);
128     int[] cur = {px, py};
129     int[] destination = {x, y};
130     ArrayList<Character> instruction = new ArrayList<Character>();
131     
132     //use path finder to find path based on different area the robot is at
133     //OUT: instruction: contains a list of instruction for the robot to move to the destination
134     if (GameParameters\&.getType(px, py) == GameParameters\&.AreaType\&.InStarting) {
135       GameUtil\&.startingFinder\&.tryFindPath(cur, destination, instruction);
136     } else {
137       GameUtil\&.searchingFinder\&.tryFindPath(cur, destination, instruction);
138     }
139     
140     //use the instruction modified by the pathFind to move to the destination
141     char lastStep = ' ';
142     int theta = 0;
143     
144     while (instruction\&.size() > 0) {
145       char step = instruction\&.remove(instruction\&.size() - 1);
146       //if the step is different from the last one, rotate to corresponding rotation
147       if (step != lastStep) {
148         theta = charToRotation(step);
149         turnTo(theta);
150       }
151       
152       //add a value to the robot traveled distance
153       if (step == GameUtil\&.leftInstruction) {
154         px--;
155       } else if (step == GameUtil\&.rightInstruction) {
156         px++;
157       } else if (step == GameUtil\&.upInstruction) {
158         py++;
159       } else {
160         py--;
161       }
162       lastStep = step;
163       
164       moveWithCorrection(1, theta);
165       //get the position of the robot
166       double[] position = odometer\&.getXYT();
167       if(Math\&.round(position[0])==px && Math\&.round(position[1])==py) {
168         //this means that the robot is at the point, so set the position to the point
169         odometer\&.setX(px);
170         odometer\&.setY(py);
171       }else {
172         //otherwise some problem might happened and we are not at the desired point, push the instruction back
173         instruction\&.add(step);
174         //reset the added value to last point
175         if (step == GameUtil\&.leftInstruction) {
176           px++;
177         } else if (step == GameUtil\&.rightInstruction) {
178           px--;
179         } else if (step == GameUtil\&.upInstruction) {
180           py--;
181         } else {
182           py++;
183         }
184       }
185     }
186   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.turn (int angle)"
Rotate the robot by certain angle
.PP
\fBParameters:\fP
.RS 4
\fIangle\fP The angle to rotate our robot to 
.RE
.PP

.PP
Definition at line 557 of file Navigation\&.java\&.
.PP
.nf
557                               {
558     leftMotor\&.rotate(convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, angle), true);
559     rightMotor\&.rotate(-convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, angle), false);
560   }
.fi
.SS "synchronized void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.turnTo (double angle)"
This method is where the logic for the odometer will run\&. Use the methods provided from the OdometerData class to implement the odometer\&.
.PP
\fBParameters:\fP
.RS 4
\fIangle\fP The angle we want our robot to turn to (in degrees) 
.br
\fIasync\fP whether return instantaneously 
.RE
.PP

.PP
Definition at line 333 of file Navigation\&.java\&.
.PP
.nf
333                                                 {
334     double dTheta;
335 
336     dTheta = angle - odometer\&.getXYT()[2];
337     if (dTheta < 0)
338       dTheta += 360;
339 
340     // TURN RIGHT
341     if (dTheta > 180) {
342       leftMotor\&.setSpeed(ROTATE_SPEED);
343       rightMotor\&.setSpeed(ROTATE_SPEED);
344       leftMotor\&.rotate(-convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, 360 - dTheta), true);
345       rightMotor\&.rotate(convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, 360 - dTheta), false);
346     }
347     // TURN LEFT
348     else {
349       leftMotor\&.setSpeed(ROTATE_SPEED);
350       rightMotor\&.setSpeed(ROTATE_SPEED);
351       leftMotor\&.rotate(convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, dTheta), true);
352       rightMotor\&.rotate(-convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, dTheta), false);
353     }
354   }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for ECSE211 - Fall 2018 - Final Project from the source code\&.
