.TH "ca.mcgill.ecse211.project.Navigation" 3 "Thu Nov 15 2018" "Version 1.0" "ECSE211 - Fall 2018 - Final Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ca.mcgill.ecse211.project.Navigation
.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBNavigation\fP (EV3LargeRegulatedMotor leftMotor, EV3LargeRegulatedMotor rightMotor)  throws OdometerExceptions "
.br
.ti -1c
.RI "double \fBcalculateAngleTo\fP (double x, double y)"
.br
.ti -1c
.RI "void \fBtravelTo\fP (double x, double y)"
.br
.ti -1c
.RI "void \fBtravelToWithCorrection\fP (int x, int y, boolean avoid)"
.br
.ti -1c
.RI "synchronized void \fBmoveWithCorrection\fP (double distance, double theta)"
.br
.ti -1c
.RI "synchronized void \fBturnTo\fP (double angle)"
.br
.ti -1c
.RI "void \fBgoThroughTunnel\fP ()  throws Exception "
.br
.ti -1c
.RI "void \fBgoToRingSet\fP ()"
.br
.ti -1c
.RI "void \fBsearchRingSet\fP (\fBRingSearcher\fP searcher, boolean correct)"
.br
.ti -1c
.RI "void \fBturn\fP (int angle)"
.br
.ti -1c
.RI "void \fBforward\fP (int speed, double distance)"
.br
.ti -1c
.RI "void \fBstop\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static int \fBconvertDistance\fP (double radius, double distance)"
.br
.in -1c
.SH "Detailed Description"
.PP 
The Navigator class extends the functionality of the \fBNavigation\fP class\&. It offers an alternative \fBtravelTo()\fP method which uses a state machine to implement obstacle avoidance\&.
.PP
The Navigator class does not override any of the methods in \fBNavigation\fP\&. All methods with the same name are overloaded i\&.e\&. the Navigator version takes different parameters than the \fBNavigation\fP version\&.
.PP
This is useful if, for instance, you want to force travel without obstacle detection over small distances\&. One place where you might want to do this is in the ObstacleAvoidance class\&. Another place is methods that implement specific features for future milestones such as retrieving an object\&.
.PP
\fBAuthor:\fP
.RS 4
Caspar Cedro 
.PP
Percy Chen 
.PP
Patrick Erath 
.PP
Anssam Ghezala 
.PP
Susan Matuszewski 
.PP
Kamy Moussavi Kafi 
.RE
.PP

.PP
Definition at line 30 of file Navigation\&.java\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.Navigation (EV3LargeRegulatedMotor leftMotor, EV3LargeRegulatedMotor rightMotor) throws \fBOdometerExceptions\fP"
This navigation class constructor sets up our robot to begin navigating a particular map
.PP
\fBParameters:\fP
.RS 4
\fIleftMotor\fP The EV3LargeRegulatedMotor instance for our left motor 
.br
\fIrightMotor\fP The EV3LargeRegulatedMotor instance for our right motor 
.RE
.PP

.PP
Definition at line 46 of file Navigation\&.java\&.
.PP
.nf
47                                 {
48     this\&.odometer = Odometer\&.getOdometer();
49     this\&.leftMotor = leftMotor;
50     this\&.rightMotor = rightMotor;
51     this\&.data = SensorData\&.getSensorData();
52     for (EV3LargeRegulatedMotor motor : new EV3LargeRegulatedMotor[] {this\&.leftMotor,
53         this\&.rightMotor}) {
54       motor\&.stop();
55       motor\&.setAcceleration(ACCELERATION);
56     }
57   }
.fi
.SH "Member Function Documentation"
.PP 
.SS "double ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.calculateAngleTo (double x, double y)"

.PP
Definition at line 59 of file Navigation\&.java\&.
.PP
.nf
59                                                      {
60     double dX = x - odometer\&.getXYT()[0];
61     double dY = y - odometer\&.getXYT()[1];
62     double theta = Math\&.atan(dX / dY);
63     if (dY < 0 && theta < Math\&.PI)
64       theta += Math\&.PI;
65     return theta;
66   }
.fi
.SS "static int ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.convertDistance (double radius, double distance)\fC [static]\fP"
This method allows the conversion of a distance to the total rotation of each wheel need to cover that distance\&.
.PP
\fBParameters:\fP
.RS 4
\fIradius\fP The radius of our wheels 
.br
\fIdistance\fP The distance traveled 
.RE
.PP
\fBReturns:\fP
.RS 4
A converted distance 
.RE
.PP

.PP
Definition at line 431 of file Navigation\&.java\&.
.PP
.nf
431                                                                     {
432     return (int) ((180\&.0 * distance) / (Math\&.PI * radius));
433   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.forward (int speed, double distance)"
Move the robot forward
.PP
\fBParameters:\fP
.RS 4
\fIspeed\fP speed to be taken 
.br
\fIdistance\fP distacne to travel 
.RE
.PP

.PP
Definition at line 408 of file Navigation\&.java\&.
.PP
.nf
408                                                   {
409     leftMotor\&.setSpeed(speed);
410     rightMotor\&.setSpeed(speed);
411     leftMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, distance * Game\&.TILE), true);
412     rightMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, distance * Game\&.TILE), false);
413   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.goThroughTunnel () throws Exception"
found the tunnel based on the ll and ur coordinate, after the method, the robot will go the the entrance of the tunnel facing the tunnel it returns the distance it needs to go for [x] and [y] in order to go through the tunnel
.PP
\fBExceptions:\fP
.RS 4
\fIException\fP 
.RE
.PP

.PP
Definition at line 233 of file Navigation\&.java\&.
.PP
.nf
233                                                  {
234     int distance = 0;
235     int[] ll, ur;
236     //first use ll and ur coordinate to calculate lr and ul of the tunnel
237     ll = GameParameters\&.TN_LL;
238     ur = GameParameters\&.TN_UR;
239     int[] lr = {ll[0], ur[1]};
240     int[] ul = {ur[0], ll[1]};
241     
242     //clone the four points (to make sure we are not modifying the original one)
243     int[][] corners = {ll\&.clone(), lr\&.clone(), ul\&.clone(), ur\&.clone()};
244     ArrayList<int[]> notIn = new ArrayList<int[]>();
245     ArrayList<int[]> points = new ArrayList<int[]>();
246     double[] position = odometer\&.getXYT();
247     
248     //search for the points that are the same as the current area of the robot
249     //these are the entrance of the tunnel, also find the other two points, those
250     //are the exit of the tunnel
251     for (int[] point : corners) {
252       if (GameParameters\&.getType(point[0], point[1]) == GameParameters
253           \&.getType((int) Math\&.round(position[0]), (int) Math\&.round(position[1]))) {
254         points\&.add(point);
255       } else {
256         notIn\&.add(point);
257       }
258     }
259     
260     //find the direction and length of the tunnel
261     //we know the entrance two points of the tunnel, so this means 
262     //the two points must have either x or y coordinate identical\&.
263     //that's the direction of the tunnel as well
264     //after identify it's direction, we find whether it is positive 
265     //or negative directed
266     if (points\&.get(0)[0] == points\&.get(1)[0]) {
267       distance = Math\&.abs(notIn\&.get(0)[0] - points\&.get(0)[0]) + 1;
268       int multi = notIn\&.get(0)[0] - points\&.get(0)[0] < 0 ? 1 : -1;
269       travelToTunnelEntrance(points, 0, multi);
270       for (int i = 0; i < notIn\&.size(); i++) {
271         //this step is to find the nearest two points that we can go two
272         //after exit the tunnel
273         notIn\&.get(i)[0] = notIn\&.get(i)[0] - multi * 1;
274       }
275     } else {
276       distance = Math\&.abs(notIn\&.get(0)[1] - points\&.get(0)[1]) + 1;
277       int multi = notIn\&.get(0)[1] - points\&.get(0)[1] < 0 ? 1 : -1;
278       travelToTunnelEntrance(points, 1, multi);
279       for (int i = 0; i < notIn\&.size(); i++) {
280       //this step is to find the nearest two points that we can go two
281       //after exit the tunnel
282         notIn\&.get(i)[1] = notIn\&.get(i)[1] - multi * 1;
283       }
284     }
285 
286     
287     double[] tunnelEnd = GameUtil\&.average(notIn\&.get(0), notIn\&.get(1));
288     double angleThoughTunnel = Math\&.toDegrees(calculateAngleTo(tunnelEnd[0], tunnelEnd[1]));
289     turnTo(angleThoughTunnel);
290     
291     // goback To correct
292     leftMotor\&.setSpeed(FORWARD_SPEED);
293     rightMotor\&.setSpeed(FORWARD_SPEED);
294     leftMotor\&.backward();
295     rightMotor\&.backward();
296     moveUntilLineDetection();
297 
298     // turn left -6 to correct the effect of the weight
299     turn(-5);
300     forward(250, distance);
301     odometer\&.setTheta(angleThoughTunnel);
302 
303     // rotate additional sensor distances to make sure the sensor will not on the balck line
304     leftMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, 2*Game\&.SEN_DIS), true);
305     rightMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, 2*Game\&.SEN_DIS), false);
306     this\&.moveOneTileWithCorrection(angleThoughTunnel);
307     double[] after = GameUtil\&.average(notIn\&.get(0), notIn\&.get(1));
308     odometer\&.setX(after[0]);
309     odometer\&.setY(after[1]);
310     // go to the nearest safe point near tunnel
311     for (int[] p : notIn) {
312       if (GameUtil\&.isSafe(p)) {
313         double toPointAngle = Math\&.toDegrees(calculateAngleTo(p[0], p[1]));
314         turnTo(toPointAngle);
315         this\&.moveOneTileWithCorrection(toPointAngle);
316         odometer\&.setX(p[0]);
317         odometer\&.setY(p[1]);
318         break;
319       }
320     }
321   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.goToRingSet ()"
this method navigate the robot to the ring set, find the right position of the ring set 
.PP
Definition at line 353 of file Navigation\&.java\&.
.PP
.nf
353                             {
354 
355   }
.fi
.SS "synchronized void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.moveWithCorrection (double distance, double theta)"
Move a certain distance with correction (using coordinate system)
.PP
\fBParameters:\fP
.RS 4
\fIdistance\fP distance to cover 
.br
\fItheta\fP theta to be corrected each time 
.RE
.PP

.PP
Definition at line 160 of file Navigation\&.java\&.
.PP
.nf
160                                                                              {
161     leftMotor\&.setSpeed(FORWARD_SPEED);
162     rightMotor\&.setSpeed(FORWARD_SPEED);
163 
164     // correct error of the distance
165     int tiles = Math\&.abs((int) Math\&.round(distance));
166     for (int i = 0; i < tiles; i++) {
167       moveOneTileWithCorrection(theta);
168     }
169   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.searchRingSet (\fBRingSearcher\fP searcher, boolean correct)"
this method approaches the ring set by paying attention to the reading of us sensor, stops at the place when the robot can reach the ring 
.PP
Definition at line 361 of file Navigation\&.java\&.
.PP
.nf
361                                                                     {
362     //Go backward to detect the line and correct the rotation
363     leftMotor\&.setSpeed(FORWARD_SPEED);
364     rightMotor\&.setSpeed(FORWARD_SPEED);
365     
366     if(correct) {
367       leftMotor\&.backward();
368       rightMotor\&.backward();
369       moveUntilLineDetection();
370       //Forward for 3 cm (approach the ring set)
371       forward(FORWARD_SPEED, 3/Game\&.TILE);
372     }
373     //rotate a little to the left to make sure that the sensor can detect the ring
374     leftMotor\&.rotate(-30, false);
375     //detect the ring color and beep based on the color
376     searcher\&.search();
377     //rotate back
378     leftMotor\&.rotate(30, false);
379     //prepare for retrieving the ring 
380     searcher\&.prepareRetrieve();
381     //go to the position where ring can be retrieved
382     forward(FORWARD_SPEED, 5/Game\&.TILE);
383     //rotate a little to the left to make sure not influence the other ring
384     //leftMotor\&.rotate(-20, false);
385     searcher\&.retrieveRing();
386     //leftMotor\&.rotate(20, false);
387     //go back to original position
388     forward(FORWARD_SPEED, -8/Game\&.TILE);
389     searcher\&.resetRodMotor();
390   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.stop ()"
Stop the motor 
.PP
Definition at line 418 of file Navigation\&.java\&.
.PP
.nf
418                      {
419     leftMotor\&.stop(true);
420     rightMotor\&.stop(false);
421   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.travelTo (double x, double y)"

.PP
Definition at line 68 of file Navigation\&.java\&.
.PP
.nf
68                                            {
69     double dX = x - odometer\&.getXYT()[0];
70     double dY = y - odometer\&.getXYT()[1];
71     double theta = calculateAngleTo(x, y);
72 
73     // Euclidean distance calculation\&.
74     double distance = Math\&.sqrt(Math\&.pow(dX, 2) + Math\&.pow(dY, 2));
75 
76     turnTo(Math\&.toDegrees(theta));
77 
78     leftMotor\&.setSpeed(FORWARD_SPEED);
79     rightMotor\&.setSpeed(FORWARD_SPEED);
80 
81     leftMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, distance * Game\&.TILE), true);
82     rightMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, distance * Game\&.TILE), false);
83   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.travelToWithCorrection (int x, int y, boolean avoid)"
This method travel the robot to desired position by following the line (Always rotate 90 degree), along with a correction
.PP
When avoid=true, the nav thread will handle traveling\&. If you want to travel without avoidance, this is also possible\&. In this case, the method in the \fBNavigation\fP class is used\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP The x coordinate to travel to (in cm) 
.br
\fIy\fP The y coordinate to travel to (in cm) 
.br
\fIavoid\fP the robot will pay attention to the distance from ultrasonic sensor to avoid abstacle when navigating 
.RE
.PP

.PP
Definition at line 97 of file Navigation\&.java\&.
.PP
.nf
97                                                                   {
98     int px = (int) Math\&.round(odometer\&.getXYT()[0]);
99     int py = (int) Math\&.round(odometer\&.getXYT()[1]);
100     int[] cur = {px, py};
101     int[] destination = {x, y};
102     ArrayList<Character> instruction = new ArrayList<Character>();
103     
104     //use path finder to find path based on different area the robot is at
105     //OUT: instruction: contains a list of instruction for the robot to move to the destination
106     if (GameParameters\&.getType(px, py) == GameParameters\&.AreaType\&.InStarting) {
107       GameUtil\&.startingFinder\&.tryFindPath(cur, destination, instruction);
108       
109     } else {
110       GameUtil\&.searchingFinder\&.tryFindPath(cur, destination, instruction);
111     }
112     
113     //use the instruction modified by the pathFind to move to the destination
114     char lastStep = ' ';
115     int theta = 0;
116     while (instruction\&.size() > 0) {
117       char step = instruction\&.remove(instruction\&.size() - 1);
118       //if the step is different from the last one, rotate to corresponding rotation
119       if (step != lastStep) {
120         theta = charToRotation(step);
121         turnTo(theta);
122       }
123       if (step == 'L') {
124         px--;
125       } else if (step == 'R') {
126         px++;
127       } else if (step == 'U') {
128         py++;
129       } else {
130         py--;
131       }
132       lastStep = step;
133       moveWithCorrection(1, theta);
134       odometer\&.setX(px);
135       odometer\&.setY(py);
136     }
137   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.turn (int angle)"
Rotate the robot by certain angle
.PP
\fBParameters:\fP
.RS 4
\fIangle\fP The angle to rotate our robot to 
.RE
.PP

.PP
Definition at line 397 of file Navigation\&.java\&.
.PP
.nf
397                               {
398     leftMotor\&.rotate(convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, angle), true);
399     rightMotor\&.rotate(-convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, angle), false);
400   }
.fi
.SS "synchronized void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.turnTo (double angle)"
(\fIImprove\fP \fIConsider to discard\fP) This method is where the logic for the odometer will run\&. Use the methods provided from the OdometerData class to implement the odometer\&.
.PP
\fBParameters:\fP
.RS 4
\fIangle\fP The angle we want our robot to turn to (in degrees) 
.br
\fIasync\fP whether return instantaneously 
.RE
.PP

.PP
Definition at line 203 of file Navigation\&.java\&.
.PP
.nf
203                                                 {
204     double dTheta;
205 
206     dTheta = angle - odometer\&.getXYT()[2];
207     if (dTheta < 0)
208       dTheta += 360;
209 
210     // TURN RIGHT
211     if (dTheta > 180) {
212       leftMotor\&.setSpeed(ROTATE_SPEED);
213       rightMotor\&.setSpeed(ROTATE_SPEED);
214       leftMotor\&.rotate(-convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, 360 - dTheta), true);
215       rightMotor\&.rotate(convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, 360 - dTheta), false);
216     }
217     // TURN LEFT
218     else {
219       leftMotor\&.setSpeed(ROTATE_SPEED);
220       rightMotor\&.setSpeed(ROTATE_SPEED);
221       leftMotor\&.rotate(convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, dTheta), true);
222       rightMotor\&.rotate(-convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, dTheta), false);
223     }
224   }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for ECSE211 - Fall 2018 - Final Project from the source code\&.
