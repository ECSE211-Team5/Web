.TH "ca.mcgill.ecse211.project.Navigation" 3 "Thu Nov 8 2018" "Version 1.0" "ECSE211 - Fall 2018 - Final Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ca.mcgill.ecse211.project.Navigation
.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBNavigation\fP (EV3LargeRegulatedMotor leftMotor, EV3LargeRegulatedMotor rightMotor)  throws OdometerExceptions "
.br
.ti -1c
.RI "void \fBtravelTo\fP (double x, double y)"
.br
.ti -1c
.RI "void \fBtravelToWithCorrection\fP (int x, int y, boolean avoid)"
.br
.ti -1c
.RI "synchronized void \fBmoveWithCorrection\fP (double distance, double theta)"
.br
.ti -1c
.RI "synchronized void \fBturnTo\fP (double angle)"
.br
.ti -1c
.RI "void \fBgoThroughTunnel\fP ()  throws Exception "
.br
.ti -1c
.RI "void \fBgoToRingSet\fP ()"
.br
.ti -1c
.RI "void \fBapproachRingSet\fP ()"
.br
.ti -1c
.RI "void \fBturn\fP (int angle)"
.br
.ti -1c
.RI "void \fBforward\fP (int speed, double distance)"
.br
.ti -1c
.RI "void \fBstop\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static int \fBconvertDistance\fP (double radius, double distance)"
.br
.in -1c
.SH "Detailed Description"
.PP 
The Navigator class extends the functionality of the \fBNavigation\fP class\&. It offers an alternative \fBtravelTo()\fP method which uses a state machine to implement obstacle avoidance\&.
.PP
The Navigator class does not override any of the methods in \fBNavigation\fP\&. All methods with the same name are overloaded i\&.e\&. the Navigator version takes different parameters than the \fBNavigation\fP version\&.
.PP
This is useful if, for instance, you want to force travel without obstacle detection over small distances\&. One place where you might want to do this is in the ObstacleAvoidance class\&. Another place is methods that implement specific features for future milestones such as retrieving an object\&.
.PP
\fBAuthor:\fP
.RS 4
Caspar Cedro 
.PP
Percy Chen 
.PP
Patrick Erath 
.PP
Anssam Ghezala 
.PP
Susan Matuszewski 
.PP
Kamy Moussavi Kafi 
.RE
.PP

.PP
Definition at line 29 of file Navigation\&.java\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.Navigation (EV3LargeRegulatedMotor leftMotor, EV3LargeRegulatedMotor rightMotor) throws \fBOdometerExceptions\fP"
This navigation class constructor sets up our robot to begin navigating a particular map
.PP
\fBParameters:\fP
.RS 4
\fIleftMotor\fP The EV3LargeRegulatedMotor instance for our left motor 
.br
\fIrightMotor\fP The EV3LargeRegulatedMotor instance for our right motor 
.RE
.PP

.PP
Definition at line 45 of file Navigation\&.java\&.
.PP
.nf
46                                 {
47     this\&.odometer = Odometer\&.getOdometer();
48     this\&.leftMotor = leftMotor;
49     this\&.rightMotor = rightMotor;
50     this\&.data = SensorData\&.getSensorData();
51     for (EV3LargeRegulatedMotor motor : new EV3LargeRegulatedMotor[] {this\&.leftMotor,
52         this\&.rightMotor}) {
53       motor\&.stop();
54       motor\&.setAcceleration(ACCELERATION);
55     }
56   }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.approachRingSet ()"
this method approaches the ring set by paying attention to the reading of us sensor, stops at the place when the robot can reach the ring 
.PP
Definition at line 304 of file Navigation\&.java\&.
.PP
.nf
304                                 {
305     
306   }
.fi
.SS "static int ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.convertDistance (double radius, double distance)\fC [static]\fP"
This method allows the conversion of a distance to the total rotation of each wheel need to cover that distance\&.
.PP
\fBParameters:\fP
.RS 4
\fIradius\fP The radius of our wheels 
.br
\fIdistance\fP The distance traveled 
.RE
.PP
\fBReturns:\fP
.RS 4
A converted distance 
.RE
.PP

.PP
Definition at line 346 of file Navigation\&.java\&.
.PP
.nf
346                                                                     {
347     return (int) ((180\&.0 * distance) / (Math\&.PI * radius));
348   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.forward (int speed, double distance)"
Move the robot forward 
.PP
\fBParameters:\fP
.RS 4
\fIspeed\fP speed to be taken 
.br
\fIdistance\fP distacne to travel 
.RE
.PP

.PP
Definition at line 323 of file Navigation\&.java\&.
.PP
.nf
323                                                   {
324     leftMotor\&.setSpeed(speed);
325     rightMotor\&.setSpeed(speed);
326     leftMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, distance * Game\&.TILE), true);
327     rightMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, distance * Game\&.TILE), false);
328   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.goThroughTunnel () throws Exception"
found the tunnel based on the ll and ur coordinate, after the method, the robot will go the the entrance of the tunnel facing the tunnel it returns the distance it needs to go for [x] and [y] in order to go through the tunnel 
.PP
\fBExceptions:\fP
.RS 4
\fIException\fP 
.RE
.PP

.PP
Definition at line 202 of file Navigation\&.java\&.
.PP
.nf
202                                                  {
203     int distance = 0;
204     int[] ll, ur;
205     ll = GameParameters\&.TN_LL;
206     ur = GameParameters\&.TN_UR;
207     int[] lr = {ll[0], ur[1]};
208     int[] ul = {ur[0], ll[1]};
209     ArrayList<int[]> notIn = new ArrayList<int[]>();
210     int[][] corners = {ll, lr, ul, ur};
211     ArrayList<int[]> points = new ArrayList<int[]>();
212     double[] position = odometer\&.getXYT();
213     for(int[] point : corners) {
214       if(GameParameters\&.getType(point[0], point[1]) == GameParameters\&.getType((int)Math\&.round(position[0]), 
215                                                                                (int)Math\&.round(position[1]))) {
216         points\&.add(point);
217       }else {
218         notIn\&.add(point);
219       }
220     }
221     if(points\&.get(0)[0] == points\&.get(1)[0]) {
222       distance= Math\&.abs(notIn\&.get(0)[0] - points\&.get(0)[0]) +1;
223       int multi = notIn\&.get(0)[0] - points\&.get(0)[0] < 0? 1 : -1;
224       travelToTunnel(points, 0, multi);
225       for(int i = 0; i < notIn\&.size(); i++) {
226         notIn\&.get(i)[0] = notIn\&.get(i)[0] - multi * 1;
227       }
228     }else {
229       distance= Math\&.abs(notIn\&.get(0)[1] - points\&.get(0)[1]) +1; 
230       int multi = notIn\&.get(0)[1] - points\&.get(0)[1] < 0? 1 : -1;
231       travelToTunnel(points, 1, multi);
232       for(int i = 0; i < notIn\&.size(); i++) {
233         notIn\&.get(i)[1] = notIn\&.get(i)[1] - multi * 1;
234       }
235     }
236     
237    
238     double[] tunnelEnd = GameUtil\&.average(notIn\&.get(0), notIn\&.get(1));
239     
240     double angleThoughTunnel = Math\&.toDegrees(calculateAngleTo(tunnelEnd[0], tunnelEnd[1]));
241     turnTo(angleThoughTunnel);
242     //goback To correct
243     leftMotor\&.backward();
244     rightMotor\&.backward();
245     moveUntilLineDetection();
246     
247     //turn left -6 to correct the effect of the weight
248     turn(-6);
249     forward(250, distance);
250     odometer\&.setTheta(angleThoughTunnel);
251     
252     //Find a nearest safe point
253     //rotate additional sensor distance to make sure the sensor will not on the balck line
254     leftMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, Game\&.SEN_DIS), true);
255     rightMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, Game\&.SEN_DIS), false);
256     leftMotor\&.forward();
257     rightMotor\&.forward();
258     moveUntilLineDetection();
259     //correnctAngle
260     odometer\&.setTheta(angleThoughTunnel);
261     
262     //go to the nearest safe point near tunnel
263     for(int[] p : notIn) {
264       if(GameUtil\&.isSafe(p)) {
265         double toPointAngle = Math\&.toDegrees(calculateAngleTo(p[0], p[1]));
266         turnTo(toPointAngle);
267         moveUntilLineDetection();
268         odometer\&.setTheta(toPointAngle);
269         break;
270       }
271     }
272   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.goToRingSet ()"
this method navigate the robot to the ring set, find the right position of the ring set 
.PP
Definition at line 296 of file Navigation\&.java\&.
.PP
.nf
296                             {
297     
298   }
.fi
.SS "synchronized void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.moveWithCorrection (double distance, double theta)"
Move a certain distance with correction (using coordinate system) 
.PP
\fBParameters:\fP
.RS 4
\fIdistance\fP distance to cover 
.br
\fItheta\fP theta to be corrected each time 
.RE
.PP

.PP
Definition at line 132 of file Navigation\&.java\&.
.PP
.nf
132                                                                              {
133     leftMotor\&.setSpeed(FORWARD_SPEED);
134     rightMotor\&.setSpeed(FORWARD_SPEED);
135 
136     //correct error of the distance
137     int tiles = Math\&.abs((int)Math\&.round(distance));
138     for (int i = 0; i < tiles; i++) {
139       moveOneTileWithCorrection(theta);
140     }
141   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.stop ()"
Stop the motor 
.PP
Definition at line 333 of file Navigation\&.java\&.
.PP
.nf
333                      {
334     leftMotor\&.stop(true);
335     rightMotor\&.stop(false);
336   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.travelTo (double x, double y)"

.PP
Definition at line 67 of file Navigation\&.java\&.
.PP
.nf
67                                            {
68     double dX = x - odometer\&.getXYT()[0];
69     double dY = y - odometer\&.getXYT()[1];
70     double theta = calculateAngleTo(x, y);
71 
72     // Euclidean distance calculation\&.
73     double distance = Math\&.sqrt(Math\&.pow(dX, 2) + Math\&.pow(dY, 2));
74 
75     turnTo(Math\&.toDegrees(theta));
76 
77     leftMotor\&.setSpeed(FORWARD_SPEED);
78     rightMotor\&.setSpeed(FORWARD_SPEED);
79 
80     leftMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, distance * Game\&.TILE), true);
81     rightMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, distance * Game\&.TILE), false);
82   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.travelToWithCorrection (int x, int y, boolean avoid)"
This method travel the robot to desired position by following the line (Always rotate 90 degree), along with a correction
.PP
When avoid=true, the nav thread will handle traveling\&. If you want to travel without avoidance, this is also possible\&. In this case, the method in the \fBNavigation\fP class is used\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP The x coordinate to travel to (in cm) 
.br
\fIy\fP The y coordinate to travel to (in cm) 
.br
\fIavoid\fP the robot will pay attention to the distance from ultrasonic sensor to avoid abstacle when navigating 
.RE
.PP

.PP
Definition at line 96 of file Navigation\&.java\&.
.PP
.nf
96                                                                   {
97     double dX = x - odometer\&.getXYT()[0];
98     double dY = y - odometer\&.getXYT()[1];
99     // double theta = Math\&.atan(dX / dY);
100     // if (dY < 0 && theta < Math\&.PI)
101     // theta += Math\&.PI;
102 
103     // Euclidean distance calculation\&.
104     // double distance = Math\&.sqrt(Math\&.pow(dX, 2) + Math\&.pow(dY, 2));
105     double theta = 0;
106     if (dX > 0\&.1) {
107       turnTo(90);
108       theta = 90;
109     } else if (dX < -0\&.1) {
110       turnTo(-90);
111       theta = -90;
112     }
113     moveWithCorrection(dX, theta);
114     odometer\&.setX(x);
115     
116     if (dY > 0\&.1) {
117       turnTo(0);
118       theta = 0;
119     } else if (dY < -0\&.1) {
120       turnTo(180);
121       theta = 180;
122     }
123     moveWithCorrection(dY, theta);
124     odometer\&.setY(y);
125   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.turn (int angle)"
Rotate the robot by certain angle
.PP
\fBParameters:\fP
.RS 4
\fIangle\fP The angle to rotate our robot to 
.RE
.PP

.PP
Definition at line 313 of file Navigation\&.java\&.
.PP
.nf
313                               {
314     leftMotor\&.rotate(convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, angle), true);
315     rightMotor\&.rotate(-convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, angle), false);
316   }
.fi
.SS "synchronized void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.turnTo (double angle)"
(\fIImprove\fP \fIConsider to discard\fP) This method is where the logic for the odometer will run\&. Use the methods provided from the OdometerData class to implement the odometer\&.
.PP
\fBParameters:\fP
.RS 4
\fIangle\fP The angle we want our robot to turn to (in degrees) 
.br
\fIasync\fP whether return instantaneously 
.RE
.PP

.PP
Definition at line 173 of file Navigation\&.java\&.
.PP
.nf
173                                                 {
174     double dTheta;
175 
176     dTheta = angle - odometer\&.getXYT()[2];
177     if (dTheta < 0)
178       dTheta += 360;
179 
180     // TURN RIGHT
181     if (dTheta > 180) {
182       leftMotor\&.setSpeed(ROTATE_SPEED);
183       rightMotor\&.setSpeed(ROTATE_SPEED);
184       leftMotor\&.rotate(-convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, 360 - dTheta), true);
185       rightMotor\&.rotate(convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, 360 - dTheta) + 10, false);
186     }
187     // TURN LEFT
188     else {
189       leftMotor\&.setSpeed(ROTATE_SPEED);
190       rightMotor\&.setSpeed(ROTATE_SPEED);
191       leftMotor\&.rotate(convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, dTheta), true);
192       rightMotor\&.rotate(-convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, dTheta) - 5, false);
193     }
194   }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for ECSE211 - Fall 2018 - Final Project from the source code\&.
